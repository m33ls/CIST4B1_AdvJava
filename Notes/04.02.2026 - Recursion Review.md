## Recursion
* A function that calls itself

```java
void function(int n) {
	System.out.println(n);
	function(n + 1);
}
```

* Loops
	* Controlling program flow
	* Recursive vs. Iterative

* Benefits of iterative programming
	* Simple to understand
	* Control
	* Easier debugging

## Why recursion?
* Many advanced data structures, like trees and graphs, are inherently recursive in their nature
	* Understanding recursion allows for more intuitive traversals and operations on these structures
* Several algorithms, particularly divide-and-conquer, leverage recursion to break down complex problems into simpler sub-problems.
* Important foundation for advanced topics
	* Recursive descent parsers
	* Backtracking algorithms
	* Dynamic programming

## Recursive Void Functions
* Divide and Conquer
	* Basic design technique
	* Break large task into subtasks
* Alternatively base cases, and recursive cases
	* Base Case: a case where we end recursion
	* Recursive Case: a case where you call recursively (with the simplified sub-task)
* Subtasks could be smaller versions of the original task
		* When they are -> Recursion

## Maze Solver
* When do base cases occur?
	* Reach (n,n)
	* Dead end (Walls, Breadcrumb trail)
	* All paths exhausted
	* Illegal maze (all 1s, all 0s but start) -> False
	* OOB
* What recursive cases?
	* Up, down, left, right
	* 1 Possible Direction
	* Multiple Possible Directions
	
## Head Recursion
 * The recursive call is at the start of the function
	* Linear recursion where only a single r

## Tail Recursion
*  The last call is a recursive call
	* Does not work with multiple recursive calls
* Tail recursive functions can easily be converted to a more efficient iterative solution
	* May be done by the compiler

## Tree Recursion
* Multiple recursive calls within the same function
	* At each level, more recursive branches